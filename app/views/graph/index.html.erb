<div id="chart"></div>
<h1 id="path">Name Path</h1>
<div class="hr"></div>
<div id="details">
  <h1 id="detail_title">Detail title</h1>
  <div id="inside"></div>
</div>
<script type="text/javascript">

var w = 960,
    h = 400,
    node,
    link,
    root,
    path;

var force = d3.layout.force() 
    .on("tick", tick)
    .size([w, h])
    .linkDistance(100)
    .charge(-300);

var vis = d3.select("#chart").append("svg:svg")
    .attr("width", w)
    .attr("height", h);

function path_to_text(p) {
  str = "";
  for (var i=0; i<p.length; i+=1) {
    str += p[i].name+" / ";
  }
  return str;
}

function person_me_callback(json) {
  if (json == null) {
    alert("Error when pulling data");
    path_update([{type:"person",name:"<%= @athena_name %>"}]);
    return;
  }
  console.log("json returned");
  root = json.graph;
  details = json.details;
  console.log(root);
  console.log(details);

  d3.select("#detail_title").text(details.name);
  var inside = d3.select("#inside");
  inside.append("h1").text("IT'S MEEEEE");
  inside.append("p").text("Course "+details.course+", Year "+details.year);
  inside.append("p").text("Lives at "+details.living_group);
  inside.append("h3").text("Likes:");
  if (details.likes && details.likes[0] != "empty") {
    inside.append("ul").classed("likes_list", true);
    var likes_list = d3.select(".likes_list");
    for (var i=0; i < details.likes.length; i+=1) {
      likes_list.append("li").text(details.likes[i]);
    }
  }

  update();

}

function person_other_callback(json) {
  console.log("json returned");
  root = json.graph;
  details = json.details;
  console.log(root);
  console.log(details);

  d3.select("#detail_title").text(details.name);
  var inside = d3.select("#inside");
  inside.append("p").text("Course "+details.course+", Year "+details.year);
  inside.append("p").text("Lives at "+details.living_group);
  inside.append("h3").text("Likes:");
  if (details.likes && details.likes[0] != "empty") {
    inside.append("ul").classed("likes_list", true);
    var likes_list = d3.select(".likes_list");
    for (var i=0; i < details.likes.length; i+=1) {
      likes_list.append("li").text(details.likes[i]);
    }
  }

  update();

}


function path_update(new_path) {
  path = new_path;
  d3.select("#path").text(path_to_text(path));
  last = path[path.length-1];
  console.log("new path");
  console.log(path);
  $("#inside").empty();
  if ( last.type == "person" ) {
    if ( last.name == "<%= @athena_name %>" ) {
      console.log("type: person = me");
      d3.json("http://stark-hamlet-8685.herokuapp.com/datapull/"+last.name, person_me_callback);
    } else {
      console.log("type: person = not me");
      d3.json("http://stark-hamlet-8685.herokuapp.com/datapull/"+last.name, person_other_callback);
    }
  }
}

path_update([{type:"person",name:"<%= @athena_name %>"}]);


function update() {
  console.log("updating");
  var nodes = flatten(root),
      links = d3.layout.tree().links(nodes);

  // Restart the force layout.
  force
      .nodes(nodes)
      .links(links)
      .start();

  // Update the links…
  link = vis.selectAll("line.link")
      .data(links, function(d) { return d.target.id; });

  // Enter any new links.
  link.enter().insert("svg:line", ".node")
      .attr("class", "link")
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

  // Exit any old links.
  link.exit().remove();

  // Update the nodes…
  node = vis.selectAll("circle.node")
      .data(nodes, function(d) { return d.id; })
      .style("fill", color);

  // Enter any new nodes.
  node.enter().append("svg:circle")
      .attr("class", "node")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })
      .attr("r", function(d) { return 20+"px"; })
      .style("fill", color)
      .on("click", click)
      .call(force.drag)
      .append("svg:title")
      .text(function(d) { return d.name });

  // Exit any old nodes.
  node.exit().remove();

/*
  // Update the labels…
  node = vis.selectAll("text.label")
      .data(nodes, function(d) { return d.name; });

  // Enter any new labels.
  node.enter().append("svg:text")
      .text(function(d) {return d.name})
      .attr("class", "label")
      .attr("x", function(d) { return d.x; })
      .attr("y", function(d) { return d.y; })
      .attr("font-family", "sans-serif")
      .attr("font-size", "11px")
      .attr("fill", "red");

  // Exit any old nodes.
  node.exit().remove();
  */
}

function tick() {
  link.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

  node.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
}

// Color leaf nodes orange, and packages white or blue.
function color(d) {
  return d._children ? "#3182bd" : d.children ? "#c6dbef" : "#fd8d3c";
}

// Toggle children on click.
function click(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
  update();
}

// Returns a list of all nodes under the root.
function flatten(root) {
  var nodes = [], i = 0;

  function recurse(node) {
    if (node.children) node.children.forEach(recurse);
    if (!node.id) node.id = ++i;
    nodes.push(node);
  }

  recurse(root);
  return nodes;
}

</script>