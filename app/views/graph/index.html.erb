<div id="chart"></div>
<h1 id="path">Name Path</h1>
<div class="hr"></div>
<div id="details">
  <div id="inside_me"><!-- INSIDE ME -->
    <h1 class="detail_title">Me:</h1>
    <%= form_tag :datapush, :id => "form_add_category", :method => :post do %>
      <%= text_field_tag :new_category_name, 'name of category' %>
      <%= submit_tag "Add", :id => "add_category_submit" %>
    <% end %>
    <ul>
    </ul>
  </div>
  <!-- INSIDE ME CATEGORY -->
  <div id="inside_me_category">
    <h1 class="detail_title">Connections:</h1>
    <%= form_tag :datapush, :id => "form_add_connection", :method => :post do %>
      <div class="ui-widget">
        <%= text_field_tag :new_connection_name, 'Type name of person' %> <%= submit_tag "Connect", :id => "add_connection_submit" %>
      </div>
    <% end %>
    <h3>My Connections:</h3>
    <ul></ul>
  </div>
  <!-- INSIDE PERSON -->
  <div id="inside_person">
    <h1 class="detail_title">Tim Beaver:</h1>
    <p>Majoring in <span id="major">X</span></p>
    <p>Year <span id="year">X</span></p>
    <p>Lives at <span id="lives_at">X</span></p>
    <p>Likes: <span id="likes">X,X,X</span></p>
  </div>
  <!-- INSIDE PERSON CATEGORY -->
  <div id="inside_person_category">
    <h1 class="detail_title">Connections:</h1>
    <ul></ul>
  </div>
</div>
<script type="text/javascript">

$('#add_category_submit').click(function(e) {
  $('#form_add_category').submit(function() {  
      var valuesToSubmit = $(this).serialize();
      console.log("Values to submit");
      console.log(valuesToSubmit);
      $.ajax({
          url: $(this).attr('action'), //sumbits it to the given url of the form
          type: 'POST',
          data: valuesToSubmit,
          dataType: "JSON" // you want a difference between normal and ajax-calls, and json is standard
      }).success(function(json){
        console.log("Category added to database successfully");
        path_update(path);
      }).fail(function(obj, textStatus, errorThrown ) {
        alert( "Error" );
        console.log("ERROR");
        console.log(obj);
        console.log(textStatus);
        console.log(errorThrown);
      }); 
      return false; // prevents normal behaviour
  });
});
$('#add_connection_submit').click(function(e) {
  $('#form_add_connection').submit(function() {  
      console.log("Adding new connections isn't ready yet!");
      return false; // prevents normal behaviour
  });
});

var w = 960,
    h = 400,
    node,
    link,
    root,
    path;

var force = d3.layout.force() 
    .on("tick", tick)
    .size([w, h])
    .friction(0.8)
    .charge(-1000)
    .gravity(0.1)
    .linkDistance(70);

var vis = d3.select("#chart").append("svg:svg")
    .attr("width", w)
    .attr("height", h);

function path_to_text(p) {
  str = "";
  for (var i=0; i<p.length; i+=1) {
    str += p[i].name+" / ";
  }
  return str;
}

function person_me_callback(root,details) {
  inside = $("#inside_me");
  inside.find(".detail_title").text(details.name);
  l = inside.find("ul");
  l.empty();
  for (var i=0; i < root.children.length; i+=1) {
    l.append("<li>"+root.children[i].name+"</li>");
  }
}

function person_other_callback(root,details) {
  console.log("Person other callback");
  inside = $("#inside_person");
  inside.find(".detail_title").text(details.name);
  inside.find("#major").text(details.course);
  inside.find("#year").text(details.year);
  inside.find("#lives_at").text(details.living_group);
  likes_str = "";
  if (details.likes && details.likes[0] != "empty") {
    for (var i=0; i < details.likes.length; i+=1) {
      if (i != 0) { likes_str += ", "; }
      likes_str += details.likes[i];
    }
  }
  inside.find("#likes").text(likes_str);
}

function person_category_callback(root,details) {
  inside = $("#inside_person_category");
  l = inside.find("ul");
  l.empty();
  for (var i=0; i < root.children.length; i+=1) {
    l.append("<li>"+root.children[i].name+"</li>");
  }
}

function person_me_category_callback(root,details) {
  inside = $("#inside_me_category");
  l = inside.find("ul");
  l.empty();
  for (var i=0; i < root.children.length; i+=1) {
    l.append("<li>"+root.children[i].name+"</li>");
  }
}


function path_update(new_path) {
  /*
  if (path && path.length == new_path.length) {
    var match = true;
    for (var i=0; i<new_path.length; i+=1) {
      if (path[i].id != new_path[i].id) {
        match = false;
      }
    }
    if (match) {
      console.log("Same path!");
      update();
      return;
    }
  }
  */
  path = new_path;
  $("#path").text(path_to_text(path));
  last = path[path.length-1];
  last_prev = null;
  if (path.length > 1) {
    last_prev = path[path.length-2];
  }
  console.log("new path");
  console.log(path);
  callback_function = function() {alert("didn't find a callback function");}
  if ( last.type == "person" ) {
    if ( last.name == "<%= @athena_name %>" ) {
      console.log("type: person = me");
      callback_function = person_me_callback;
      $("#inside_me").show();
      $("#inside_me_category").hide();
      $("#inside_person").hide();
      $("#inside_person_category").hide();
    } else {
      console.log("type: person = not me");
      callback_function = person_other_callback;
      $("#inside_me").hide();
      $("#inside_me_category").hide();
      $("#inside_person").show();
      $("#inside_person_category").hide();
    }
  } else if ( last.type == "category" ) {
    if ( last_prev.name == "<%= @athena_name %>" ) {
      console.log("type: my category");
      callback_function = person_me_category_callback;
      $("#inside_me").hide();
      $("#inside_me_category").show();
      $("#inside_person").hide();
      $("#inside_person_category").hide();
    } else {
      console.log("type: other's category");
      callback_function = person_category_callback;
      $("#inside_me").hide();
      $("#inside_me_category").hide();
      $("#inside_person").hide();
      $("#inside_person_category").show();
    }
  }
  
  parent_name = "";
  if (last.type == "category") {
    parent_name = path[path.length-2].name;
  }
  $.ajax({
    type: "GET",
    url: "http://stark-hamlet-8685.herokuapp.com/datapull",
    data: { type: last.type, id: last.id, name: last.name, parent: parent_name }
  }).done(function(data, textStatus, jqXHR ) {
    console.log("data recieved "+textStatus);
    if (data == null) { alert("Data recieved was empty"); }
    //combine current path and new expansion
    path[path.length-1].id = data.graph.id; //make sure id of last node in path is correct
    if (!root) {
      console.log("First time setting root");
      root = data.graph;
    } else {
      if (last.id == root.id) {
        root.children = data.graph.children;
      } else {
        var tempnode = root,
            found = false;
        while (tempnode.children.length != 0) {
          for (var i=0; i<tempnode.children.length; i+=1) {
            if (tempnode.children[i].id == last.id) {
              tempnode.children[i].children = data.graph.children;
              tempnode.children = [tempnode.children[i]];
              found = true;
              break;
            }
          }
          if (found) { break; }
          tempnode = tempnode.children[0]
        }
        if (!found) { alert("NODE NOT FOUND"); }
        console.log("NODES AFTER COMBINING!!!!")
        console.log(tempnode);
      }
    }

    details = data.details;
    console.log("root -------------------------");
    console.log(root);
    console.log("details -------------------------");
    console.log(details);
    callback_function(data.graph,details);
    update();
  }).fail(function(obj, textStatus, errorThrown ) {
    alert( "Error" );
    console.log("ERROR");
    console.log(obj);
    console.log(textStatus);
    console.log(errorThrown);
  });
}

path_update([{type:"person",id:"first",name:"<%= @athena_name %>"}]);


function update() {
  console.log("updating");
  var nodes = flatten(root),
      links = d3.layout.tree().links(nodes);
  console.log(nodes);

  // Restart the force layout.
  force
      .nodes(nodes)
      .links(links)
      .start();

  // Update the links…
  link = vis.selectAll("line.link")
      .data(links, function(d) { console.log("Assigning id to link "+d.target.id); return d.source.id + "-" + d.target.id; });

  // Enter any new links.
  link.enter().insert("svg:line", ".node")
      .attr("class", "link")
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

  // Exit any old links.
  link.exit().remove();

  // Update the nodes…
  node = vis.selectAll("g.node")
      .data(nodes, function(d) { console.log("Assigning id to node "+d.id); return d.id; });

  var last_id = path[path.length-1].id,
      xxx = 0,
      yyy = 0;
  for (var i=0; i<nodes.length; i+=1) {
    if (nodes[i].id == last_id) {
      xxx = nodes[i].x;
      yyy = nodes[i].y;
      console.log("found nooooooooooooooooooodde!");
      break;
    }
  }
  if (xxx == 0 && yyy == 0) {
    alert("ID not found for expansion!");
    xxx = Math.random()*w;
    yyy = Math.random()*h;
  }

  circle_nodes = vis.selectAll("g.node circle").style("fill", color);
  rect_nodes = vis.selectAll("g.node rect").style("fill", color);

  // Enter any new nodes.
  enter_node = node.enter().append("svg:g")
              .attr("class","node")
              .on("click", click)
              .on("mouseover", node_mouseover)
              .on("mouseout", node_mouseout)
              .call(force.drag);
              //.attr("transform", function(d) { return "translate(" + d.x + ","+ d.y + ")"; })

  enter_node.filter(function(d) { return d.type == "person"; })
      .append("svg:circle")
      .attr("r", function(d) { return 20+"px"; })
      .style("fill", color);
      //.attr("cx", function(d) { return d.x; })
      //.attr("cy", function(d) { return d.y; })

  enter_node.filter(function(d) { return d.type == "category"; })
      .append("svg:rect")
      .attr("x",-15)
      .attr("y",-15)
      .attr("width",30)
      .attr("height",30)
      .style("fill", color);
      //.attr("cx", function(d) { return d.x; })
      //.attr("cy", function(d) { return d.y; })

  enter_node.append("svg:text")
      .attr("text-anchor", "middle")
      .style("fill", "#333333")
      .text(function(d) { return d.name; });

  // Exit any old nodes.
  node.exit().remove();

  node.each(function(d) {
    var inPath = false;
    for (var i=0; i<path.length; i+=1) {
      if (path[i].id == d.id) {
        inPath = true;
        break;
      }
    }
    if (!inPath) {
      angle = 2*Math.PI*Math.random();
      valx = xxx+Math.cos(angle)*(50);
      valy = yyy+Math.sin(angle)*(50);
      d.x = valx;
      d.y = valy;
      d.px = valx;
      d.py = valy;
      console.log("Moving node to "+valx+", "+valy);
    }
  })

}

function tick() {
  link.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

  //node.attr("cx", function(d) { return d.x; })
  //    .attr("cy", function(d) { return d.y; });
  node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

}

// Color leaf nodes orange, and packages white or blue.
function color(d) {
  if (d.highlight) {
    return "#00FFFF";
  }
  for (var i=0; i<path.length-1; i+=1) {
    if (d.id == path[i].id) {
      return "#AAAAAA";
    }
  }
  if (d.type == "person") {
    return "#3cfd8d";
  }
  return "#fd8d3c";
}

// Toggle children on click.
function click(d) {
  for (var i=0; i<path.length; i+=1) {
    if (d.id == path[i].id) {
      console.log("Clicked on something already in path");
      path_update(path.slice(0,i+1));
      return;
    }
  }
  console.log("Clicked on point not in path");
  if (d.type == "category") {
    var p = path.slice(0);
    p.push({type:"category",id:d.id,name:d.name});
    path_update(p);
  } else if (d.type == "person") {
    var p = path.slice(0);
    p.push({type:"person",id:d.id,name:d.name});
    path_update(p);
  }
}

function node_mouseover(d) {
  console.log("mouseover");
  d.highlight = true;
  circle_nodes = vis.selectAll("g.node circle").style("fill", color);
  rect_nodes = vis.selectAll("g.node rect").style("fill", color);
}
function node_mouseout(d) {
  console.log("mouseout");
  d.highlight = false;
  circle_nodes = vis.selectAll("g.node circle").style("fill", color);
  rect_nodes = vis.selectAll("g.node rect").style("fill", color);
}

// Returns a list of all nodes under the root.
function flatten(root) {
  console.log("Flattening");
  console.log(root);

  var nodes = [], i = 0;

  function recurse(node) {
    if (node.children) node.children.forEach(recurse);
    if (!node.id) {
      alert("Setting ID");
      node.id = ++i;
    }
    nodes.push(node);
  }

  recurse(root);
  return nodes;
}

</script>
<script>
$(function() {
  $( "#new_connection_name" ).autocomplete({
    source: "http://stark-hamlet-8685.herokuapp.com/userpull",
    minLength: 2,
      source: function( request, response ) {
        var term = request.term;
        $.getJSON( "http://stark-hamlet-8685.herokuapp.com/userpull", request, function( data, status, xhr ) {
          response( data );
        });
      }
  });
});
</script>